# 设计原则

> 本次模拟器设计采用cycle-accurate的模式
>
> 假设处理器在运行中几乎没有数据冒险的情况存在，仅仅考虑结构冒险，此外控制冒险也是没有的，因为就是分支结构

## 整体架构

整体采取流水线的方式编，为流水线上每一级都编写一个对应的模块，每个模块都能接受一定的输入并进行输出，此外每个模块都能根据需要stall掉整个流水线。每个模块针对每条指令都能给出一个延时情况，采用周期表示，没有小数的问题，此外还能给出执行完整条指令的能耗，如此我们将编译完的指令按照顺序进行流水线即可得到整体的延时和能耗信息。

针对出现的跨核数据通信，使用一个专门的NoC模块处理多核之间的情况

## 数据计算
IF/ID/RI/SEU 部分使用自己编写的简易架构实现，延时信息全部假设为 1 cycle(目前的实现是可以保证的)，功耗的信息仍需要使用DC跑出来。
ReRAM/SRAM部分使用MNSIM2.0的PE跑出来。VEU使用较粗的力度进行模拟，算一次运算需要多少周期和能耗，然后根据指令的向量长度计算运算次数，直接乘积。DTU准备使用清华MNSIM中的NoC（Mesh结构，booksim2）计算网络延时和能耗（待定，具体可以看MNSIM2.0论文中采用的模拟方式）
On-chip memory使用MNSIM2.0中的数据计算延时和能耗信息。

## details

> 有改变，暂时废止该部分，仅供参考

我们可以参考RTL的设计思路，一个ticktok模拟一次寄存器内容的变化，假设每个部件的寄存器都在部件的顶部，每次recv都是先改变寄存器的值，然后之后的组合电路开始执行，最后是通过send送到下一个部件。
函数的执行顺序可以考虑如下，首先执行ticktock函数，更新模块内部寄存器的变化，同时计算各种能耗的信息。之后运行stall函数，综合本模块和其他模块的信息，决定是否需要暂停流水线，如何暂停流水线。最后根据流水线暂停的情况进行流水线的流动，将上一级流水的信息传输到下一级流水，如果要是被



update (配置上一轮recv的数据)-> ticktoc(计算功耗等信息，配置send的数据)->recv(上一个部件发送的)->send(发送自己的数据)

## 核间的通讯模型

每个核都拥有一个GateWay用于将该核的数据发送出来，每个核能看见的设备只有这个GateWay，GateWay会将核的请求通过NoC发送到其他核的GateWay。

目前实现的NoC是阻塞式的，这要求send和recv都被执行到的时候才会发生实际的数据传输。具体而言，每个GateWay都有一个寄存器记录外部其他核的情况，当一个核想接收其他核的数据时，首先发送一个message，然后目的核将该核寄存器的状态设置为准备好。一个核想要发送数据时，首先检测目的核的寄存器状态，如果为准备好，那么发送数据并将寄存器状态重新设置为等待。如此能够保证数据通信之间是阻塞进行的。

明确一下顺序，首先接收核要先往发送核发送一个准备就绪数据包，发送核会设置相应的状态，准备就绪后发送核进行数据发送。这样，接收核先执行，发送就绪数据包，然后等待数据，发送核执行到之后发现接收核已经就绪了，所以直接发送。如果发送核先执行到，那么接收核的状态一定是未准备好的，因此进入等待，等到接收核执行到对应的指令后发送就绪数据包之后，就能继续发送数据进行传输了。

