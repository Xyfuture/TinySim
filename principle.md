# 设计原则

> 本次模拟器设计采用cycle-accurate的模式
>
> 假设处理器在运行中几乎没有数据冒险的情况存在，仅仅考虑结构冒险，此外控制冒险也是没有的，因为就是分支结构

## 整体架构

整体采取流水线的方式编写，为流水线上每一级都编写一个对应的模块，每个模块都能接受一定的输入并进行输出，此外每个模块都能根据需要stall掉整个流水线。每个模块针对每条指令都能给出一个延时情况，采用周期表示，没有小数的问题，此外还能给出执行完整条指令的能耗，如此我们将编译完的指令按照顺序进行流水线即可得到整体的延时和能耗信息。

针对出现的跨核数据通信，使用一个专门的NoC模块处理多核之间的情况

## 数据计算
IF/ID/RI/SEU 部分使用自己编写的简易架构实现，延时信息全部假设为 1 cycle(目前的实现是可以保证的)，功耗的信息仍需要使用DC跑出来。
ReRAM/SRAM部分使用MNSIM2.0的PE跑出来。VEU使用较粗的力度进行模拟，算一次运算需要多少周期和能耗，然后根据指令的向量长度计算运算次数，直接乘积。DTU准备使用清华MNSIM中的NoC（Mesh结构，booksim2）计算网络延时和能耗（待定，具体可以看MNSIM2.0论文中采用的模拟方式）
On-chip memory使用MNSIM2.0中的数据计算延时和能耗信息。

## details

> 有改变，暂时废止该部分，仅供参考

我们可以参考RTL的设计思路，一个ticktok模拟一次寄存器内容的变化，假设每个部件的寄存器都在部件的顶部，每次recv都是先改变寄存器的值，然后之后的组合电路开始执行，最后是通过send送到下一个部件。
函数的执行顺序可以考虑如下，首先执行ticktock函数，更新模块内部寄存器的变化，同时计算各种能耗的信息。之后运行stall函数，综合本模块和其他模块的信息，决定是否需要暂停流水线，如何暂停流水线。最后根据流水线暂停的情况进行流水线的流动，将上一级流水的信息传输到下一级流水，如果要是被



update (配置上一轮recv的数据)-> ticktoc(计算功耗等信息，配置send的数据)->recv(上一个部件发送的)->send(发送自己的数据)

